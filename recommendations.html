<!DOCTYPE html>
}


function rand(min, max){ return Math.random() * (max - min) + min; }


function initStars(){
const count = Math.floor((innerWidth * innerHeight) / 9000);
stars = new Array(count).fill(0).map(() => ({
x: rand(0, W),
y: rand(0, H),
r: rand(0.6, 1.8) * DPR,
tw: rand(0.2, 1),
a: rand(0.4, 0.9),
depth: rand(0.4, 1.5) /* depth controls parallax */
}));
}


function draw(){
ctx.clearRect(0,0,W,H);
// subtle vignette background glow
const grad = ctx.createRadialGradient(W*0.1, H*0.1, 0, W*0.1, H*0.1, Math.max(W,H));
grad.addColorStop(0, 'rgba(30,44,80,0.15)');
grad.addColorStop(1, 'rgba(11,16,32,0)');
ctx.fillStyle = grad;
ctx.fillRect(0,0,W,H);


const cx = (mouseX - innerWidth/2) / innerWidth; // -0.5..0.5
const cy = (mouseY - innerHeight/2) / innerHeight;


for (const s of stars){
// parallax shift based on depth and mouse position
const px = s.x + cx * 20 * s.depth;
const py = s.y + cy * 20 * s.depth;
const twinkle = 0.5 + 0.5 * Math.sin(performance.now()/1000 * s.tw + s.x);
ctx.globalAlpha = s.a * (0.6 + 0.4 * twinkle);
ctx.beginPath();
ctx.arc(px, py, s.r, 0, Math.PI*2);
ctx.fillStyle = 'rgba(200,220,255,0.9)';
ctx.fill();
}
ctx.globalAlpha = 1;
requestAnimationFrame(draw);
}


window.addEventListener('resize', resize);
window.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
resize();
draw();


/* SCROLL REVEAL: observe each UL and add .show when in view */
const lists = document.querySelectorAll('ul');
const io = new IntersectionObserver((entries) => {
entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('show'); });
}, { rootMargin: '0px 0px -10% 0px', threshold: 0.15 });
lists.forEach(el => io.observe(el));


/* MAGNETIC BACK LINK: gentle attract-and-release */
const back = document.querySelector('.back-link');
let rafId = null;


function onMove(e){
const rect = back.getBoundingClientRect();
const mx = e.clientX - (rect.left + rect.width/2);
const my = e.clientY - (rect.top + rect.height/2);
const dist = Math.hypot(mx,my);
const radius = 160; // influence area
if (dist < radius){
const strength = (1 - dist / radius);
const tx = mx * 0.15 * strength;
const ty = my * 0.15 * strength;
back.style.transform = `translate(${tx}px, ${ty}px)`;
} else {
back.style.transform = 'translate(0,0)';
}
}


window.addEventListener('pointermove', onMove);
</script>
</body>
</html>
